{"version":3,"sources":["webpack:///aframe-lensflare-component.min.js","webpack:///webpack/bootstrap 6eab8e9799d28b624549?43f4","webpack:///./index.js?2645"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","AFRAME","Error","THREE","registerComponent","schema","src","type","createLight","default","position","target","intensity","relative","size","lightColor","lightDistance","lightAngle","Math","PI","lightPenumbra","lightDecay","lightType","oneOf","multiple","setLightType","settings","SpotLight","Color","PointLight","DirectionalLight","init","scene","document","querySelector","object3D","self","this","el","parentPos","parentEl","sceneEl","data","Vector3","x","y","z","textureLoader","TextureLoader","textureFlare","load","texture","xhr","lensFlare","LensFlare","AdditiveBlending","copy","light","toLowerCase","hasTarget","set","SceneUtils","attach","updateMatrixWorld","add","update","oldData","remove","pause","play"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAE,WACAE,GAAAJ,EACAK,QAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,QAAA,EAGAF,EAAAD,QAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,GAGAV,EAAA,KDMM,SAASI,EAAQD,GAEtB,YE3CD,IAAsB,mBAAXQ,QACT,KAAM,IAAIC,OAAM,+DAGlB,IAAqB,mBAAVC,OACT,KAAM,IAAID,OAAM,8DAMlBD,QAAOG,kBAAkB,aACvBC,QACEC,KACEC,KAAM,SAERC,aACED,KAAM,UACNE,SAAS,GAEXC,UACEH,KAAM,QAERI,QACEJ,KAAM,UAERK,WACEL,KAAM,SACNE,QAAS,GAEXI,UACEN,KAAM,UACNE,SAAS,GAEXK,MACEP,KAAM,SACNE,QAAS,KAEXM,YACER,KAAM,SACNE,QAAS,sBAEXO,eACET,KAAM,SACNE,QAAS,GAEXQ,YACEV,KAAM,SACNE,QAASS,KAAKC,GAAK,GAErBC,eACEb,KAAM,SACNE,QAAS,MAEXY,YACEd,KAAM,SACNE,QAAS,GAEXa,WACEb,QAAS,OACTc,OAAQ,cAAe,QAAS,UAOpCC,UAAU,EASVC,aAAc,SAASlB,EAAMmB,GAC3B,OAAQnB,GACN,IAAK,OACH,MAAO,IAAIJ,OAAMwB,UAAU,GAAIxB,OAAMyB,MAAMF,EAASX,YAAaW,EAASd,UAAWc,EAASV,cAAeU,EAAST,WAAYS,EAASN,cAAeM,EAASL,WACrK,KAAK,QACH,MAAO,IAAIlB,OAAM0B,WAAW,GAAI1B,OAAMyB,MAAMF,EAASX,YAAaW,EAASd,UAAWc,EAASV,cAAeU,EAASL,WACzH,KAAK,cACH,MAAO,IAAIlB,OAAM2B,iBAAiB,GAAI3B,OAAMyB,MAAMF,EAASX,YAAaW,EAASd,aAMvFmB,KAAM,WACJ,GAAMC,GAAQC,SAASC,cAAc,WAAWC,SAC9CC,EAAOC,KAAKC,GAAGH,SACfI,EAAYH,EAAK1B,SAEf8B,EAAWH,KAAKC,GAAGH,SACvBM,EAAUJ,KAAKC,GAAGG,QAAQN,SAGtBzB,EAAW2B,KAAKK,KAAK7B,SAAW,GAAIV,OAAMwC,QAAQJ,EAAUK,EAAIP,KAAKK,KAAKhC,SAASkC,EAAGL,EAAUM,EAAIR,KAAKK,KAAKhC,SAASmC,EAAGN,EAAUO,EAAIT,KAAKK,KAAKhC,SAASoC,GAAKT,KAAKK,KAAKhC,SAGxKqC,EAAgB,GAAI5C,OAAM6C,cAC1BC,EAAeF,EAAcG,KAAKb,KAAKK,KAAKpC,IAChD,SAAS6C,GACP,MAAOA,IAET,SAASC,KAGT,SAASA,GACP,KAAM,IAAIlD,OAAM,+CAQpB,IAJAmC,KAAKgB,UAAY,GAAIlD,OAAMmD,UAAUL,EAAcZ,KAAKK,KAAK5B,KAAM,EAAKX,MAAMoD,iBAAkB,GAAIpD,OAAMyB,MAAMS,KAAKK,KAAK3B,aAC1HsB,KAAKgB,UAAU3C,SAAS8C,KAAK9C,GAGzB2B,KAAKK,KAAKlC,YAAa,CAEzB,GAAIiD,GAAQpB,KAAKZ,aAAaY,KAAKK,KAAKpB,UAAUoC,cAAerB,KAAKK,MAGlEiB,IAAatB,KAAKK,KAAK/B,QAAU0B,KAAKK,KAAK/B,MAG3CgD,KAAWF,EAAM9C,OAASsB,SAASC,cAAcG,KAAKK,KAAK/B,QAAQwB,UACvEsB,EAAM/C,SAASkD,IAAIlD,EAASkC,EAAGlC,EAASmC,EAAGnC,EAASoC,GAGjDT,KAAKK,KAAK7B,UACXV,MAAM0D,WAAWC,OAAOL,EAAOhB,EAASD,GACxCrC,MAAM0D,WAAWC,OAAOzB,KAAKgB,UAAWZ,EAASD,GACjDC,EAAQsB,qBAER/B,EAAMgC,IAAIP,OAITpB,MAAKK,KAAK7B,UACXV,MAAM0D,WAAWC,OAAOzB,KAAKgB,UAAWZ,EAASD,GACjDC,EAAQsB,qBAER/B,EAAMgC,IAAI3B,KAAKgB,YAWrBY,OAAQ,SAASC,KAQjBC,OAAQ,aAWRC,MAAO,aAMPC,KAAM","file":"aframe-lensflare-component.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/* global AFRAME */\n\t/* global THREE */\n\t\n\tif (typeof AFRAME === 'undefined') {\n\t  throw new Error('Component attempted to register before AFRAME was available.');\n\t}\n\t\n\tif (typeof THREE === 'undefined') {\n\t  throw new Error('Component attempted to register before THREE was available.');\n\t}\n\t\n\t/**\n\t * A-Frame Lensflare Component component for A-Frame.\n\t */\n\tAFRAME.registerComponent('lensflare', {\n\t  schema: {\n\t    src: {\n\t      type: 'asset'\n\t    },\n\t    createLight: {\n\t      type: 'boolean',\n\t      default: true\n\t    },\n\t    position: {\n\t      type: 'vec3'\n\t    },\n\t    target: {\n\t      type: 'string'\n\t    },\n\t    intensity: {\n\t      type: 'number',\n\t      default: 5\n\t    },\n\t    relative: {\n\t      type: 'boolean',\n\t      default: true\n\t    },\n\t    size: {\n\t      type: 'number',\n\t      default: 500\n\t    },\n\t    lightColor: {\n\t      type: 'string',\n\t      default: 'rgb(255, 255, 255)'\n\t    },\n\t    lightDistance: {\n\t      type: 'number',\n\t      default: 4.0\n\t    },\n\t    lightAngle: {\n\t      type: 'number',\n\t      default: Math.PI / 3\n\t    },\n\t    lightPenumbra: {\n\t      type: 'number',\n\t      default: 0.077\n\t    },\n\t    lightDecay: {\n\t      type: 'number',\n\t      default: 1\n\t    },\n\t    lightType: {\n\t      default: 'spot',\n\t      oneOf: ['directional', 'point', 'spot']\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Set if component needs multiple instancing.\n\t   */\n\t  multiple: true,\n\t\n\t  /**\n\t   * setLightType - Create a light based on lightType\n\t   *\n\t   * @param  {String} type Type of the light, supplied as a string.\n\t   * @param  {Object} settings Additional settings to pass to the light. E.g. angle and decay\n\t   * @return {THREE.Light}  A THREE.JS light object\n\t   */\n\t  setLightType: function setLightType(type, settings) {\n\t    switch (type) {\n\t      case 'spot':\n\t        return new THREE.SpotLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightAngle, settings.lightPenumbra, settings.lightDecay);\n\t      case 'point':\n\t        return new THREE.PointLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightDecay);\n\t      case 'directional':\n\t        return new THREE.DirectionalLight(new THREE.Color(settings.lightColor), settings.intensity);\n\t    }\n\t  },\n\t  /**\n\t   * Called once when component is attached. Generally for initial setup.\n\t   */\n\t  init: function init() {\n\t    var scene = document.querySelector('a-scene').object3D,\n\t        self = this.el.object3D,\n\t        parentPos = self.position;\n\t\n\t    var parentEl = this.el.object3D,\n\t        sceneEl = this.el.sceneEl.object3D;\n\t\n\t    //Determine positioning\n\t    var position = this.data.relative ? new THREE.Vector3(parentPos.x + this.data.position.x, parentPos.y + this.data.position.y, parentPos.z + this.data.position.z) : this.data.position;\n\t\n\t    //Load texture\n\t    var textureLoader = new THREE.TextureLoader();\n\t    var textureFlare = textureLoader.load(this.data.src, function (texture) {\n\t      return texture;\n\t    }, function (xhr) {\n\t      //console.log((xhr.loaded / xhr.total * 100) + '% loaded')\n\t    }, function (xhr) {\n\t      throw new Error('An error occured loading the Flare texture');\n\t    });\n\t\n\t    this.lensFlare = new THREE.LensFlare(textureFlare, this.data.size, 0.0, THREE.AdditiveBlending, new THREE.Color(this.data.lightColor));\n\t    this.lensFlare.position.copy(position);\n\t\n\t    //Determine if the user wants a light\n\t    if (this.data.createLight) {\n\t\n\t      var light = this.setLightType(this.data.lightType.toLowerCase(), this.data);\n\t\n\t      //Has a target been supplied?\n\t      var hasTarget = this.data.target ? this.data.target : false;\n\t\n\t      //Set light target.\n\t      if (hasTarget) light.target = document.querySelector(this.data.target).object3D;\n\t      light.position.set(position.x, position.y, position.z);\n\t\n\t      //If relative, we want to attach the lensflare, and the light as child objects and call updateMatrixWorld once.\n\t      if (this.data.relative) {\n\t        THREE.SceneUtils.attach(light, sceneEl, parentEl);\n\t        THREE.SceneUtils.attach(this.lensFlare, sceneEl, parentEl);\n\t        sceneEl.updateMatrixWorld();\n\t      } else {\n\t        scene.add(light);\n\t      }\n\t    } else {\n\t      //If relative, we want to attach the lensflare as a child object. This is so our lensflare works with animation updates.\n\t      if (this.data.relative) {\n\t        THREE.SceneUtils.attach(this.lensFlare, sceneEl, parentEl);\n\t        sceneEl.updateMatrixWorld();\n\t      } else {\n\t        scene.add(this.lensFlare);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Called when component is attached and when component data changes.\n\t   * Generally modifies the entity based on the data.\n\t   */\n\t  update: function update(oldData) {},\n\t\n\t  /**\n\t   * Called when a component is removed (e.g., via removeAttribute).\n\t   * Generally undoes all modifications to the entity.\n\t   */\n\t  remove: function remove() {},\n\t\n\t  /**\n\t   * Called on each scene tick.\n\t   */\n\t  // tick: function (t) { },\n\t\n\t  /**\n\t   * Called when entity pauses.\n\t   * Use to stop or remove any dynamic or background behavior such as events.\n\t   */\n\t  pause: function pause() {},\n\t\n\t  /**\n\t   * Called when entity resumes.\n\t   * Use to continue or add any dynamic or background behavior such as events.\n\t   */\n\t  play: function play() {}\n\t});\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// aframe-lensflare-component.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 6eab8e9799d28b624549","/* global AFRAME */\n/* global THREE */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.')\n}\n\nif (typeof THREE === 'undefined') {\n  throw new Error('Component attempted to register before THREE was available.')\n}\n\n/**\n * A-Frame Lensflare Component component for A-Frame.\n */\nAFRAME.registerComponent('lensflare', {\n  schema: {\n    src: {\n      type: 'asset'\n    },\n    createLight: {\n      type: 'boolean',\n      default: true\n    },\n    position: {\n      type: 'vec3'\n    },\n    target: {\n      type: 'string'\n    },\n    intensity: {\n      type: 'number',\n      default: 5\n    },\n    relative: {\n      type: 'boolean',\n      default: true\n    },\n    size: {\n      type: 'number',\n      default: 500\n    },\n    lightColor: {\n      type: 'string',\n      default: 'rgb(255, 255, 255)'\n    },\n    lightDistance: {\n      type: 'number',\n      default: 4.0,\n    },\n    lightAngle: {\n      type: 'number',\n      default: Math.PI / 3,\n    },\n    lightPenumbra: {\n      type: 'number',\n      default: 0.077,\n    },\n    lightDecay: {\n      type: 'number',\n      default: 1,\n    },\n    lightType: {\n      default: 'spot',\n      oneOf: ['directional', 'point', 'spot']\n    }\n  },\n\n  /**\n   * Set if component needs multiple instancing.\n   */\n  multiple: true,\n\n  /**\n   * setLightType - Create a light based on lightType\n   *\n   * @param  {String} type Type of the light, supplied as a string.\n   * @param  {Object} settings Additional settings to pass to the light. E.g. angle and decay\n   * @return {THREE.Light}  A THREE.JS light object\n   */\n  setLightType: function(type, settings) {\n    switch (type) {\n      case 'spot':\n        return new THREE.SpotLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightAngle, settings.lightPenumbra, settings.lightDecay)\n      case 'point':\n        return new THREE.PointLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightDecay)\n      case 'directional':\n        return new THREE.DirectionalLight(new THREE.Color(settings.lightColor), settings.intensity)\n    }\n  },\n  /**\n   * Called once when component is attached. Generally for initial setup.\n   */\n  init: function() {\n    const scene = document.querySelector('a-scene').object3D,\n      self = this.el.object3D,\n      parentPos = self.position\n\n    let parentEl = this.el.object3D,\n    sceneEl = this.el.sceneEl.object3D\n\n    //Determine positioning\n    let position = this.data.relative ? new THREE.Vector3(parentPos.x + this.data.position.x, parentPos.y + this.data.position.y, parentPos.z + this.data.position.z) : this.data.position\n\n    //Load texture\n    const textureLoader = new THREE.TextureLoader()\n    const textureFlare = textureLoader.load(this.data.src,\n      function(texture) {\n        return texture\n      },\n      function(xhr) {\n        //console.log((xhr.loaded / xhr.total * 100) + '% loaded')\n      },\n      function(xhr) {\n        throw new Error('An error occured loading the Flare texture')\n      }\n    )\n\n    this.lensFlare = new THREE.LensFlare(textureFlare, this.data.size, 0.0, THREE.AdditiveBlending, new THREE.Color(this.data.lightColor))\n    this.lensFlare.position.copy(position)\n\n    //Determine if the user wants a light\n    if (this.data.createLight) {\n\n      let light = this.setLightType(this.data.lightType.toLowerCase(), this.data)\n\n      //Has a target been supplied?\n      let hasTarget = (this.data.target) ? this.data.target : false\n\n      //Set light target.\n      if (hasTarget) light.target = document.querySelector(this.data.target).object3D\n      light.position.set(position.x, position.y, position.z)\n\n      //If relative, we want to attach the lensflare, and the light as child objects and call updateMatrixWorld once.\n      if(this.data.relative){\n        THREE.SceneUtils.attach(light, sceneEl, parentEl)\n        THREE.SceneUtils.attach(this.lensFlare, sceneEl, parentEl)\n        sceneEl.updateMatrixWorld()\n      } else {\n        scene.add(light)\n      }\n    } else {\n      //If relative, we want to attach the lensflare as a child object. This is so our lensflare works with animation updates.\n      if(this.data.relative){\n        THREE.SceneUtils.attach(this.lensFlare, sceneEl, parentEl)\n        sceneEl.updateMatrixWorld()\n      } else {\n        scene.add(this.lensFlare)\n      }\n    }\n\n\n  },\n\n  /**\n   * Called when component is attached and when component data changes.\n   * Generally modifies the entity based on the data.\n   */\n  update: function(oldData) {\n\n  },\n\n  /**\n   * Called when a component is removed (e.g., via removeAttribute).\n   * Generally undoes all modifications to the entity.\n   */\n  remove: function() {},\n\n  /**\n   * Called on each scene tick.\n   */\n  // tick: function (t) { },\n\n  /**\n   * Called when entity pauses.\n   * Use to stop or remove any dynamic or background behavior such as events.\n   */\n  pause: function() {},\n\n  /**\n   * Called when entity resumes.\n   * Use to continue or add any dynamic or background behavior such as events.\n   */\n  play: function() {}\n});\n\n\n\n// WEBPACK FOOTER //\n// ./index.js"],"sourceRoot":""}