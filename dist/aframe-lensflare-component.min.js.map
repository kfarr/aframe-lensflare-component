{"version":3,"sources":["webpack:///aframe-lensflare-component.min.js","webpack:///webpack/bootstrap d1cf0bc6b2e28ee8fcca?ce15","webpack:///./index.js?2645","webpack:///./Lensflare.js?f53d"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","AFRAME","Error","THREE","registerComponent","schema","src","type","createLight","default","position","target","intensity","relative","size","lightColor","lightDistance","lightAngle","Math","PI","lightPenumbra","lightDecay","lightType","oneOf","multiple","setLightType","settings","SpotLight","Color","PointLight","DirectionalLight","init","scene","document","querySelector","object3D","self","this","el","parentPos","parentEl","sceneEl","data","Vector3","x","y","z","textureLoader","TextureLoader","textureFlare","load","currentSrc","texture","undefined","error","lensFlare","Lensflare","AdditiveBlending","copy","light","toLowerCase","hasTarget","set","attach","updateMatrixWorld","add","update","oldData","remove","pause","play","Mesh","Geometry","MeshBasicMaterial","opacity","transparent","frustumCulled","renderOrder","Infinity","positionScreen","positionView","tempMap","DataTexture","Uint8Array","RGBFormat","minFilter","NearestFilter","magFilter","wrapS","ClampToEdgeWrapping","wrapT","needsUpdate","occlusionMap","geometry","material1a","RawShaderMaterial","uniforms","scale","value","screenPosition","vertexShader","join","fragmentShader","depthTest","depthWrite","material1b","map","mesh1","elements","shader","LensflareElement","Shader","material2","color","Vector2","blending","mesh2","addElement","element","push","screenPositionPixels","validArea","Box2","viewport","Vector4","onBeforeRender","renderer","camera","getCurrentViewport","invAspect","w","halfViewportWidth","halfViewportHeight","min","max","setFromMatrixPosition","matrixWorld","applyMatrix4","matrixWorldInverse","projectionMatrix","containsPoint","copyFramebufferToTexture","renderBufferDirect","vecX","vecY","i","l","length","distance","uniformsNeedUpdate","dispose","prototype","Object","create","constructor","isLensflare","BufferGeometry","float32Array","Float32Array","interleavedBuffer","InterleavedBuffer","setIndex","addAttribute","InterleavedBufferAttribute"],"mappings":"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","file":"aframe-lensflare-component.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* global AFRAME */\n\t/* global THREE */\n\t\n\tif (typeof AFRAME === 'undefined') {\n\t  throw new Error('Component attempted to register before AFRAME was available.');\n\t}\n\t\n\tif (typeof THREE === 'undefined') {\n\t  throw new Error('Component attempted to register before THREE was available.');\n\t}\n\t\n\t__webpack_require__(1);\n\t\n\t/**\n\t * A-Frame Lensflare Component component for A-Frame.\n\t */\n\tAFRAME.registerComponent('lensflare', {\n\t  schema: {\n\t    src: {\n\t      type: 'asset'\n\t    },\n\t    createLight: {\n\t      type: 'boolean',\n\t      default: true\n\t    },\n\t    position: {\n\t      type: 'vec3'\n\t    },\n\t    target: {\n\t      type: 'string'\n\t    },\n\t    intensity: {\n\t      type: 'number',\n\t      default: 5\n\t    },\n\t    relative: {\n\t      type: 'boolean',\n\t      default: true\n\t    },\n\t    size: {\n\t      type: 'number',\n\t      default: 500\n\t    },\n\t    lightColor: {\n\t      type: 'string',\n\t      default: 'rgb(255, 255, 255)'\n\t    },\n\t    lightDistance: {\n\t      type: 'number',\n\t      default: 4.0\n\t    },\n\t    lightAngle: {\n\t      type: 'number',\n\t      default: Math.PI / 3\n\t    },\n\t    lightPenumbra: {\n\t      type: 'number',\n\t      default: 0.077\n\t    },\n\t    lightDecay: {\n\t      type: 'number',\n\t      default: 1\n\t    },\n\t    lightType: {\n\t      default: 'spot',\n\t      oneOf: ['directional', 'point', 'spot']\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Set if component needs multiple instancing.\n\t   */\n\t  multiple: true,\n\t\n\t  /**\n\t   * setLightType - Create a light based on lightType\n\t   *\n\t   * @param  {String} type Type of the light, supplied as a string.\n\t   * @param  {Object} settings Additional settings to pass to the light. E.g. angle and decay\n\t   * @return {THREE.Light}  A THREE.JS light object\n\t   */\n\t  setLightType: function setLightType(type, settings) {\n\t    switch (type) {\n\t      case 'spot':\n\t        return new THREE.SpotLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightAngle, settings.lightPenumbra, settings.lightDecay);\n\t      case 'point':\n\t        return new THREE.PointLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightDecay);\n\t      case 'directional':\n\t        return new THREE.DirectionalLight(new THREE.Color(settings.lightColor), settings.intensity);\n\t    }\n\t  },\n\t  /**\n\t   * Called once when component is attached. Generally for initial setup.\n\t   */\n\t  init: function init() {\n\t\n\t    var scene = document.querySelector('a-scene').object3D;\n\t    var self = this.el.object3D;\n\t    var parentPos = self.position;\n\t\n\t    var parentEl = this.el.object3D;\n\t    var sceneEl = this.el.sceneEl.object3D;\n\t\n\t    //Determine positioning\n\t    var position = this.data.relative ? new THREE.Vector3(parentPos.x + this.data.position.x, parentPos.y + this.data.position.y, parentPos.z + this.data.position.z) : this.data.position;\n\t\n\t    //Load texture (Three r84 upward doesn't support progress)\n\t    var textureLoader = new THREE.TextureLoader();\n\t    var textureFlare = textureLoader.load(this.data.src.currentSrc, function (texture) {\n\t      return texture;\n\t    }, undefined, function (error) {\n\t      throw new Error('An error occured loading the Flare texture');\n\t    });\n\t\n\t    this.lensFlare = new THREE.Lensflare(textureFlare, this.data.size, 0.0, THREE.AdditiveBlending, new THREE.Color(this.data.lightColor));\n\t    this.lensFlare.position.copy(position);\n\t\n\t    //Determine if the user wants a light\n\t    if (this.data.createLight) {\n\t\n\t      var light = this.setLightType(this.data.lightType.toLowerCase(), this.data);\n\t\n\t      //Has a target been supplied?\n\t      var hasTarget = this.data.target ? this.data.target : false;\n\t\n\t      //Set light target.\n\t      if (hasTarget) light.target = document.querySelector(this.data.target).object3D;\n\t      light.position.set(position.x, position.y, position.z);\n\t\n\t      //If relative, we want to attach the lensflare, and the light as child objects and call updateMatrixWorld once.\n\t      if (this.data.relative) {\n\t        parentEl.attach(light);\n\t        parentEl.attach(this.lensFlare);\n\t        sceneEl.updateMatrixWorld();\n\t      } else {\n\t        scene.add(light);\n\t      }\n\t    } else {\n\t      //If relative, we want to attach the lensflare as a child object. This is so our lensflare works with animation updates.\n\t      if (this.data.relative) {\n\t        parentEl.attach(this.lensFlare);\n\t        sceneEl.updateMatrixWorld();\n\t      } else {\n\t        scene.add(this.lensFlare);\n\t      }\n\t    }\n\t  },\n\t\n\t  /**\n\t   * Called when component is attached and when component data changes.\n\t   * Generally modifies the entity based on the data.\n\t   */\n\t  update: function update(oldData) {},\n\t\n\t  /**\n\t   * Called when a component is removed (e.g., via removeAttribute).\n\t   * Generally undoes all modifications to the entity.\n\t   */\n\t  remove: function remove() {},\n\t\n\t  /**\n\t   * Called on each scene tick.\n\t   */\n\t  // tick: function (t) { },\n\t\n\t  /**\n\t   * Called when entity pauses.\n\t   * Use to stop or remove any dynamic or background behavior such as events.\n\t   */\n\t  pause: function pause() {},\n\t\n\t  /**\n\t   * Called when entity resumes.\n\t   * Use to continue or add any dynamic or background behavior such as events.\n\t   */\n\t  play: function play() {}\n\t});\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * @author Mugen87 / https://github.com/Mugen87\n\t * @author mrdoob / http://mrdoob.com/\n\t */\n\t\n\tTHREE.Lensflare = function () {\n\t\n\t\tTHREE.Mesh.call(this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial({ opacity: 0, transparent: true }));\n\t\n\t\tthis.type = 'Lensflare';\n\t\tthis.frustumCulled = false;\n\t\tthis.renderOrder = Infinity;\n\t\n\t\t//\n\t\n\t\tvar positionScreen = new THREE.Vector3();\n\t\tvar positionView = new THREE.Vector3();\n\t\n\t\t// textures\n\t\n\t\tvar tempMap = new THREE.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, THREE.RGBFormat);\n\t\ttempMap.minFilter = THREE.NearestFilter;\n\t\ttempMap.magFilter = THREE.NearestFilter;\n\t\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\n\t\ttempMap.needsUpdate = true;\n\t\n\t\tvar occlusionMap = new THREE.DataTexture(new Uint8Array(16 * 16 * 3), 16, 16, THREE.RGBFormat);\n\t\tocclusionMap.minFilter = THREE.NearestFilter;\n\t\tocclusionMap.magFilter = THREE.NearestFilter;\n\t\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\n\t\tocclusionMap.needsUpdate = true;\n\t\n\t\t// material\n\t\n\t\tvar geometry = THREE.Lensflare.Geometry;\n\t\n\t\tvar material1a = new THREE.RawShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'void main() {', '\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\\n'),\n\t\t\tfragmentShader: ['precision highp float;', 'void main() {', '\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );', '}'].join('\\n'),\n\t\t\tdepthTest: true,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t});\n\t\n\t\tvar material1b = new THREE.RawShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: tempMap },\n\t\t\t\t'scale': { value: null },\n\t\t\t\t'screenPosition': { value: null }\n\t\t\t},\n\t\t\tvertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'void main() {', '\tvUV = uv;', '\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );', '}'].join('\\n'),\n\t\t\tfragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'varying vec2 vUV;', 'void main() {', '\tgl_FragColor = texture2D( map, vUV );', '}'].join('\\n'),\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: false\n\t\t});\n\t\n\t\t// the following object is used for occlusionMap generation\n\t\n\t\tvar mesh1 = new THREE.Mesh(geometry, material1a);\n\t\n\t\t//\n\t\n\t\tvar elements = [];\n\t\n\t\tvar shader = THREE.LensflareElement.Shader;\n\t\n\t\tvar material2 = new THREE.RawShaderMaterial({\n\t\t\tuniforms: {\n\t\t\t\t'map': { value: null },\n\t\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t\t'color': { value: new THREE.Color(0xffffff) },\n\t\t\t\t'scale': { value: new THREE.Vector2() },\n\t\t\t\t'screenPosition': { value: new THREE.Vector3() }\n\t\t\t},\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\ttransparent: true,\n\t\t\tdepthWrite: false\n\t\t});\n\t\n\t\tvar mesh2 = new THREE.Mesh(geometry, material2);\n\t\n\t\tthis.addElement = function (element) {\n\t\n\t\t\telements.push(element);\n\t\t};\n\t\n\t\t//\n\t\n\t\tvar scale = new THREE.Vector2();\n\t\tvar screenPositionPixels = new THREE.Vector2();\n\t\tvar validArea = new THREE.Box2();\n\t\tvar viewport = new THREE.Vector4();\n\t\n\t\tthis.onBeforeRender = function (renderer, scene, camera) {\n\t\n\t\t\trenderer.getCurrentViewport(viewport);\n\t\n\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\t\tvar halfViewportWidth = viewport.z / 2.0;\n\t\t\tvar halfViewportHeight = viewport.w / 2.0;\n\t\n\t\t\tvar size = 16 / viewport.w;\n\t\t\tscale.set(size * invAspect, size);\n\t\n\t\t\tvalidArea.min.set(viewport.x, viewport.y);\n\t\t\tvalidArea.max.set(viewport.x + (viewport.z - 16), viewport.y + (viewport.w - 16));\n\t\n\t\t\t// calculate position in screen space\n\t\n\t\t\tpositionView.setFromMatrixPosition(this.matrixWorld);\n\t\t\tpositionView.applyMatrix4(camera.matrixWorldInverse);\n\t\n\t\t\tif (positionView.z > 0) return; // lensflare is behind the camera\n\t\n\t\t\tpositionScreen.copy(positionView).applyMatrix4(camera.projectionMatrix);\n\t\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\t\n\t\t\tscreenPositionPixels.x = viewport.x + positionScreen.x * halfViewportWidth + halfViewportWidth - 8;\n\t\t\tscreenPositionPixels.y = viewport.y + positionScreen.y * halfViewportHeight + halfViewportHeight - 8;\n\t\n\t\t\t// screen cull\n\t\n\t\t\tif (validArea.containsPoint(screenPositionPixels)) {\n\t\n\t\t\t\t// save current RGB to temp texture\n\t\n\t\t\t\trenderer.copyFramebufferToTexture(screenPositionPixels, tempMap);\n\t\n\t\t\t\t// render pink quad\n\t\n\t\t\t\tvar uniforms = material1a.uniforms;\n\t\t\t\tuniforms[\"scale\"].value = scale;\n\t\t\t\tuniforms[\"screenPosition\"].value = positionScreen;\n\t\n\t\t\t\trenderer.renderBufferDirect(camera, null, geometry, material1a, mesh1, null);\n\t\n\t\t\t\t// copy result to occlusionMap\n\t\n\t\t\t\trenderer.copyFramebufferToTexture(screenPositionPixels, occlusionMap);\n\t\n\t\t\t\t// restore graphics\n\t\n\t\t\t\tvar uniforms = material1b.uniforms;\n\t\t\t\tuniforms[\"scale\"].value = scale;\n\t\t\t\tuniforms[\"screenPosition\"].value = positionScreen;\n\t\n\t\t\t\trenderer.renderBufferDirect(camera, null, geometry, material1b, mesh1, null);\n\t\n\t\t\t\t// render elements\n\t\n\t\t\t\tvar vecX = -positionScreen.x * 2;\n\t\t\t\tvar vecY = -positionScreen.y * 2;\n\t\n\t\t\t\tfor (var i = 0, l = elements.length; i < l; i++) {\n\t\n\t\t\t\t\tvar element = elements[i];\n\t\n\t\t\t\t\tvar uniforms = material2.uniforms;\n\t\n\t\t\t\t\tuniforms[\"color\"].value.copy(element.color);\n\t\t\t\t\tuniforms[\"map\"].value = element.texture;\n\t\t\t\t\tuniforms[\"screenPosition\"].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\t\tuniforms[\"screenPosition\"].value.y = positionScreen.y + vecY * element.distance;\n\t\n\t\t\t\t\tvar size = element.size / viewport.w;\n\t\t\t\t\tvar invAspect = viewport.w / viewport.z;\n\t\n\t\t\t\t\tuniforms[\"scale\"].value.set(size * invAspect, size);\n\t\n\t\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\t\n\t\t\t\t\trenderer.renderBufferDirect(camera, null, geometry, material2, mesh2, null);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\tthis.dispose = function () {\n\t\n\t\t\tmaterial1a.dispose();\n\t\t\tmaterial1b.dispose();\n\t\t\tmaterial2.dispose();\n\t\n\t\t\ttempMap.dispose();\n\t\t\tocclusionMap.dispose();\n\t\n\t\t\tfor (var i = 0, l = elements.length; i < l; i++) {\n\t\n\t\t\t\telements[i].texture.dispose();\n\t\t\t}\n\t\t};\n\t};\n\t\n\tTHREE.Lensflare.prototype = Object.create(THREE.Mesh.prototype);\n\tTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\n\tTHREE.Lensflare.prototype.isLensflare = true;\n\t\n\t//\n\t\n\tTHREE.LensflareElement = function (texture, size, distance, color) {\n\t\n\t\tthis.texture = texture;\n\t\tthis.size = size || 1;\n\t\tthis.distance = distance || 0;\n\t\tthis.color = color || new THREE.Color(0xffffff);\n\t};\n\t\n\tTHREE.LensflareElement.Shader = {\n\t\n\t\tuniforms: {\n\t\n\t\t\t'map': { value: null },\n\t\t\t'occlusionMap': { value: null },\n\t\t\t'color': { value: null },\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\t\n\t\t},\n\t\n\t\tvertexShader: ['precision highp float;', 'uniform vec3 screenPosition;', 'uniform vec2 scale;', 'uniform sampler2D occlusionMap;', 'attribute vec3 position;', 'attribute vec2 uv;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '\tvUV = uv;', '\tvec2 pos = position.xy;', '\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );', '\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );', '\tvVisibility =        visibility.r / 9.0;', '\tvVisibility *= 1.0 - visibility.g / 9.0;', '\tvVisibility *=       visibility.b / 9.0;', '\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );', '}'].join('\\n'),\n\t\n\t\tfragmentShader: ['precision highp float;', 'uniform sampler2D map;', 'uniform vec3 color;', 'varying vec2 vUV;', 'varying float vVisibility;', 'void main() {', '\tvec4 texture = texture2D( map, vUV );', '\ttexture.a *= vVisibility;', '\tgl_FragColor = texture;', '\tgl_FragColor.rgb *= color;', '}'].join('\\n')\n\t\n\t};\n\t\n\tTHREE.Lensflare.Geometry = function () {\n\t\n\t\tvar geometry = new THREE.BufferGeometry();\n\t\n\t\tvar float32Array = new Float32Array([-1, -1, 0, 0, 0, 1, -1, 0, 1, 0, 1, 1, 0, 1, 1, -1, 1, 0, 0, 1]);\n\t\n\t\tvar interleavedBuffer = new THREE.InterleavedBuffer(float32Array, 5);\n\t\n\t\tgeometry.setIndex([0, 1, 2, 0, 2, 3]);\n\t\tgeometry.addAttribute('position', new THREE.InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n\t\tgeometry.addAttribute('uv', new THREE.InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n\t\n\t\treturn geometry;\n\t}();\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// aframe-lensflare-component.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d1cf0bc6b2e28ee8fcca","/* global AFRAME */\n/* global THREE */\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.')\n}\n\nif (typeof THREE === 'undefined') {\n  throw new Error('Component attempted to register before THREE was available.')\n}\n\nrequire('./Lensflare')\n\n/**\n * A-Frame Lensflare Component component for A-Frame.\n */\nAFRAME.registerComponent('lensflare', {\n  schema: {\n    src: {\n      type: 'asset'\n    },\n    createLight: {\n      type: 'boolean',\n      default: true\n    },\n    position: {\n      type: 'vec3'\n    },\n    target: {\n      type: 'string'\n    },\n    intensity: {\n      type: 'number',\n      default: 5\n    },\n    relative: {\n      type: 'boolean',\n      default: true\n    },\n    size: {\n      type: 'number',\n      default: 500\n    },\n    lightColor: {\n      type: 'string',\n      default: 'rgb(255, 255, 255)'\n    },\n    lightDistance: {\n      type: 'number',\n      default: 4.0,\n    },\n    lightAngle: {\n      type: 'number',\n      default: Math.PI / 3,\n    },\n    lightPenumbra: {\n      type: 'number',\n      default: 0.077,\n    },\n    lightDecay: {\n      type: 'number',\n      default: 1,\n    },\n    lightType: {\n      default: 'spot',\n      oneOf: ['directional', 'point', 'spot']\n    }\n  },\n\n  /**\n   * Set if component needs multiple instancing.\n   */\n  multiple: true,\n\n  /**\n   * setLightType - Create a light based on lightType\n   *\n   * @param  {String} type Type of the light, supplied as a string.\n   * @param  {Object} settings Additional settings to pass to the light. E.g. angle and decay\n   * @return {THREE.Light}  A THREE.JS light object\n   */\n  setLightType: function (type, settings) {\n    switch (type) {\n      case 'spot':\n        return new THREE.SpotLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightAngle, settings.lightPenumbra, settings.lightDecay)\n      case 'point':\n        return new THREE.PointLight(new THREE.Color(settings.lightColor), settings.intensity, settings.lightDistance, settings.lightDecay)\n      case 'directional':\n        return new THREE.DirectionalLight(new THREE.Color(settings.lightColor), settings.intensity)\n    }\n  },\n  /**\n   * Called once when component is attached. Generally for initial setup.\n   */\n  init: function () {\n\n    const scene = document.querySelector('a-scene').object3D;\n    const self = this.el.object3D\n    const parentPos = self.position\n\n    const parentEl = this.el.object3D\n    const sceneEl = this.el.sceneEl.object3D\n\n    //Determine positioning\n    const position = this.data.relative ? new THREE.Vector3(parentPos.x + this.data.position.x, parentPos.y + this.data.position.y, parentPos.z + this.data.position.z) : this.data.position\n\n    //Load texture (Three r84 upward doesn't support progress)\n    const textureLoader = new THREE.TextureLoader()\n    const textureFlare = textureLoader.load(this.data.src.currentSrc,\n      function (texture) {\n        return texture\n      },\n      undefined,\n      function (error ) {\n        throw new Error('An error occured loading the Flare texture')\n      }\n    )\n\n    this.lensFlare = new THREE.Lensflare(textureFlare, this.data.size, 0.0, THREE.AdditiveBlending, new THREE.Color(this.data.lightColor))\n    this.lensFlare.position.copy(position)\n\n    //Determine if the user wants a light\n    if (this.data.createLight) {\n\n      const light = this.setLightType(this.data.lightType.toLowerCase(), this.data)\n\n      //Has a target been supplied?\n      const hasTarget = (this.data.target) ? this.data.target : false\n\n      //Set light target.\n      if (hasTarget) light.target = document.querySelector(this.data.target).object3D\n      light.position.set(position.x, position.y, position.z)\n\n      //If relative, we want to attach the lensflare, and the light as child objects and call updateMatrixWorld once.\n      if (this.data.relative) {\n        parentEl.attach(light)\n        parentEl.attach(this.lensFlare)\n        sceneEl.updateMatrixWorld()\n      } else {\n        scene.add(light)\n      }\n    } else {\n      //If relative, we want to attach the lensflare as a child object. This is so our lensflare works with animation updates.\n      if (this.data.relative) {\n        parentEl.attach(this.lensFlare)\n        sceneEl.updateMatrixWorld()\n      } else {\n        scene.add(this.lensFlare)\n      }\n    }\n\n\n  },\n\n  /**\n   * Called when component is attached and when component data changes.\n   * Generally modifies the entity based on the data.\n   */\n  update: function (oldData) {\n\n  },\n\n  /**\n   * Called when a component is removed (e.g., via removeAttribute).\n   * Generally undoes all modifications to the entity.\n   */\n  remove: function () { },\n\n  /**\n   * Called on each scene tick.\n   */\n  // tick: function (t) { },\n\n  /**\n   * Called when entity pauses.\n   * Use to stop or remove any dynamic or background behavior such as events.\n   */\n  pause: function () { },\n\n  /**\n   * Called when entity resumes.\n   * Use to continue or add any dynamic or background behavior such as events.\n   */\n  play: function () { }\n});\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","/**\n * @author Mugen87 / https://github.com/Mugen87\n * @author mrdoob / http://mrdoob.com/\n */\n\nTHREE.Lensflare = function () {\n\n\tTHREE.Mesh.call( this, THREE.Lensflare.Geometry, new THREE.MeshBasicMaterial( { opacity: 0, transparent: true } ) );\n\n\tthis.type = 'Lensflare';\n\tthis.frustumCulled = false;\n\tthis.renderOrder = Infinity;\n\n\t//\n\n\tvar positionScreen = new THREE.Vector3();\n\tvar positionView = new THREE.Vector3();\n\n\t// textures\n\n\tvar tempMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\ttempMap.minFilter = THREE.NearestFilter;\n\ttempMap.magFilter = THREE.NearestFilter;\n\ttempMap.wrapS = THREE.ClampToEdgeWrapping;\n\ttempMap.wrapT = THREE.ClampToEdgeWrapping;\n\ttempMap.needsUpdate = true;\n\n\tvar occlusionMap = new THREE.DataTexture( new Uint8Array( 16 * 16 * 3 ), 16, 16, THREE.RGBFormat );\n\tocclusionMap.minFilter = THREE.NearestFilter;\n\tocclusionMap.magFilter = THREE.NearestFilter;\n\tocclusionMap.wrapS = THREE.ClampToEdgeWrapping;\n\tocclusionMap.wrapT = THREE.ClampToEdgeWrapping;\n\tocclusionMap.needsUpdate = true;\n\n\t// material\n\n\tvar geometry = THREE.Lensflare.Geometry;\n\n\tvar material1a = new THREE.RawShaderMaterial( {\n\t\tuniforms: {\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\t\t},\n\t\tvertexShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform vec3 screenPosition;',\n\t\t\t'uniform vec2 scale;',\n\n\t\t\t'attribute vec3 position;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\t\tfragmentShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\t\tdepthTest: true,\n\t\tdepthWrite: false,\n\t\ttransparent: false\n\t} );\n\n\tvar material1b = new THREE.RawShaderMaterial( {\n\t\tuniforms: {\n\t\t\t'map': { value: tempMap },\n\t\t\t'scale': { value: null },\n\t\t\t'screenPosition': { value: null }\n\t\t},\n\t\tvertexShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform vec3 screenPosition;',\n\t\t\t'uniform vec2 scale;',\n\n\t\t\t'attribute vec3 position;',\n\t\t\t'attribute vec2 uv;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tvUV = uv;',\n\n\t\t\t'\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\t\tfragmentShader: [\n\n\t\t\t'precision highp float;',\n\n\t\t\t'uniform sampler2D map;',\n\n\t\t\t'varying vec2 vUV;',\n\n\t\t\t'void main() {',\n\n\t\t\t'\tgl_FragColor = texture2D( map, vUV );',\n\n\t\t\t'}'\n\n\t\t].join( '\\n' ),\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: false\n\t} );\n\n\t// the following object is used for occlusionMap generation\n\n\tvar mesh1 = new THREE.Mesh( geometry, material1a );\n\n\t//\n\n\tvar elements = [];\n\n\tvar shader = THREE.LensflareElement.Shader;\n\n\tvar material2 = new THREE.RawShaderMaterial( {\n\t\tuniforms: {\n\t\t\t'map': { value: null },\n\t\t\t'occlusionMap': { value: occlusionMap },\n\t\t\t'color': { value: new THREE.Color( 0xffffff ) },\n\t\t\t'scale': { value: new THREE.Vector2() },\n\t\t\t'screenPosition': { value: new THREE.Vector3() }\n\t\t},\n\t\tvertexShader: shader.vertexShader,\n\t\tfragmentShader: shader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\ttransparent: true,\n\t\tdepthWrite: false\n\t} );\n\n\tvar mesh2 = new THREE.Mesh( geometry, material2 );\n\n\tthis.addElement = function ( element ) {\n\n\t\telements.push( element );\n\n\t};\n\n\t//\n\n\tvar scale = new THREE.Vector2();\n\tvar screenPositionPixels = new THREE.Vector2();\n\tvar validArea = new THREE.Box2();\n\tvar viewport = new THREE.Vector4();\n\n\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\trenderer.getCurrentViewport( viewport );\n\n\t\tvar invAspect = viewport.w / viewport.z;\n\t\tvar halfViewportWidth = viewport.z / 2.0;\n\t\tvar halfViewportHeight = viewport.w / 2.0;\n\n\t\tvar size = 16 / viewport.w;\n\t\tscale.set( size * invAspect, size );\n\n\t\tvalidArea.min.set( viewport.x, viewport.y );\n\t\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\n\n\t\t// calculate position in screen space\n\n\t\tpositionView.setFromMatrixPosition( this.matrixWorld );\n\t\tpositionView.applyMatrix4( camera.matrixWorldInverse );\n\n\t\tif ( positionView.z > 0 ) return; // lensflare is behind the camera\n\n\t\tpositionScreen.copy( positionView ).applyMatrix4( camera.projectionMatrix );\n\n\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\n\n\t\tscreenPositionPixels.x = viewport.x + ( positionScreen.x * halfViewportWidth ) + halfViewportWidth - 8;\n\t\tscreenPositionPixels.y = viewport.y + ( positionScreen.y * halfViewportHeight ) + halfViewportHeight - 8;\n\n\t\t// screen cull\n\n\t\tif ( validArea.containsPoint( screenPositionPixels ) ) {\n\n\t\t\t// save current RGB to temp texture\n\n\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, tempMap );\n\n\t\t\t// render pink quad\n\n\t\t\tvar uniforms = material1a.uniforms;\n\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1a, mesh1, null );\n\n\t\t\t// copy result to occlusionMap\n\n\t\t\trenderer.copyFramebufferToTexture( screenPositionPixels, occlusionMap );\n\n\t\t\t// restore graphics\n\n\t\t\tvar uniforms = material1b.uniforms;\n\t\t\tuniforms[ \"scale\" ].value = scale;\n\t\t\tuniforms[ \"screenPosition\" ].value = positionScreen;\n\n\t\t\trenderer.renderBufferDirect( camera, null, geometry, material1b, mesh1, null );\n\n\t\t\t// render elements\n\n\t\t\tvar vecX = - positionScreen.x * 2;\n\t\t\tvar vecY = - positionScreen.y * 2;\n\n\t\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\t\tvar element = elements[ i ];\n\n\t\t\t\tvar uniforms = material2.uniforms;\n\n\t\t\t\tuniforms[ \"color\" ].value.copy( element.color );\n\t\t\t\tuniforms[ \"map\" ].value = element.texture;\n\t\t\t\tuniforms[ \"screenPosition\" ].value.x = positionScreen.x + vecX * element.distance;\n\t\t\t\tuniforms[ \"screenPosition\" ].value.y = positionScreen.y + vecY * element.distance;\n\n\t\t\t\tvar size = element.size / viewport.w;\n\t\t\t\tvar invAspect = viewport.w / viewport.z;\n\n\t\t\t\tuniforms[ \"scale\" ].value.set( size * invAspect, size );\n\n\t\t\t\tmaterial2.uniformsNeedUpdate = true;\n\n\t\t\t\trenderer.renderBufferDirect( camera, null, geometry, material2, mesh2, null );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tmaterial1a.dispose();\n\t\tmaterial1b.dispose();\n\t\tmaterial2.dispose();\n\n\t\ttempMap.dispose();\n\t\tocclusionMap.dispose();\n\n\t\tfor ( var i = 0, l = elements.length; i < l; i ++ ) {\n\n\t\t\telements[ i ].texture.dispose();\n\n\t\t}\n\n\t};\n\n};\n\nTHREE.Lensflare.prototype = Object.create( THREE.Mesh.prototype );\nTHREE.Lensflare.prototype.constructor = THREE.Lensflare;\nTHREE.Lensflare.prototype.isLensflare = true;\n\n//\n\nTHREE.LensflareElement = function ( texture, size, distance, color ) {\n\n\tthis.texture = texture;\n\tthis.size = size || 1;\n\tthis.distance = distance || 0;\n\tthis.color = color || new THREE.Color( 0xffffff );\n\n};\n\nTHREE.LensflareElement.Shader = {\n\n\tuniforms: {\n\n\t\t'map': { value: null },\n\t\t'occlusionMap': { value: null },\n\t\t'color': { value: null },\n\t\t'scale': { value: null },\n\t\t'screenPosition': { value: null }\n\n\t},\n\n\tvertexShader: [\n\n\t\t'precision highp float;',\n\n\t\t'uniform vec3 screenPosition;',\n\t\t'uniform vec2 scale;',\n\n\t\t'uniform sampler2D occlusionMap;',\n\n\t\t'attribute vec3 position;',\n\t\t'attribute vec2 uv;',\n\n\t\t'varying vec2 vUV;',\n\t\t'varying float vVisibility;',\n\n\t\t'void main() {',\n\n\t\t'\tvUV = uv;',\n\n\t\t'\tvec2 pos = position.xy;',\n\n\t\t'\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\n\t\t'\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\n\n\t\t'\tvVisibility =        visibility.r / 9.0;',\n\t\t'\tvVisibility *= 1.0 - visibility.g / 9.0;',\n\t\t'\tvVisibility *=       visibility.b / 9.0;',\n\n\t\t'\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\n\n\t\t'}'\n\n\t].join( '\\n' ),\n\n\tfragmentShader: [\n\n\t\t'precision highp float;',\n\n\t\t'uniform sampler2D map;',\n\t\t'uniform vec3 color;',\n\n\t\t'varying vec2 vUV;',\n\t\t'varying float vVisibility;',\n\n\t\t'void main() {',\n\n\t\t'\tvec4 texture = texture2D( map, vUV );',\n\t\t'\ttexture.a *= vVisibility;',\n\t\t'\tgl_FragColor = texture;',\n\t\t'\tgl_FragColor.rgb *= color;',\n\n\t\t'}'\n\n\t].join( '\\n' )\n\n};\n\nTHREE.Lensflare.Geometry = ( function () {\n\n\tvar geometry = new THREE.BufferGeometry();\n\n\tvar float32Array = new Float32Array( [\n\t\t- 1, - 1, 0, 0, 0,\n\t\t1, - 1, 0, 1, 0,\n\t\t1, 1, 0, 1, 1,\n\t\t- 1, 1, 0, 0, 1\n\t] );\n\n\tvar interleavedBuffer = new THREE.InterleavedBuffer( float32Array, 5 );\n\n\tgeometry.setIndex( [ 0, 1, 2,\t0, 2, 3 ] );\n\tgeometry.addAttribute( 'position', new THREE.InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );\n\tgeometry.addAttribute( 'uv', new THREE.InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );\n\n\treturn geometry;\n\n} )();\n\n\n\n// WEBPACK FOOTER //\n// ./Lensflare.js"],"sourceRoot":""}